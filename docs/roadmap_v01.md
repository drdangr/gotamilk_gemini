## Roadmap v0.1 — мультипользовательские сценарии (Vercel + Supabase)

### Цель
- **Добавить аутентификацию пользователей**, хранение их данных в БД и **совместную работу в реальном времени** над одним списком покупок.
- Деплой фронтенда на **Vercel**, бэкенд-часть — **Supabase (Auth, Postgres, Realtime, RLS)**.

### Текущее состояние прототипа (анализ)
- SPA на React (Vite). Состояние списка держится в `useShoppingList` через `useReducer`.
- Данные берутся из констант (`INITIAL_ITEMS`, `INITIAL_PRODUCT_CATALOG`, `INITIAL_ALIASES`), пользователя имитирует `CURRENT_USER`.
- Нет персистентности, нет настоящего шаринга и аутентификации.
- Интеграция Gemini (`@google/genai`) для парсинга команд и «умной» сортировки. Требуется перевести ключ на `import.meta.env.VITE_*`.

### Целевая архитектура
- **Frontend**: текущий React SPA (Vite), деплой на Vercel (Static/SPA, preview deployments).
- **Backend**: Supabase
  - Auth (email+OAuth), хранение профилей
  - Postgres (таблицы: `profiles`, `lists`, `list_members`, `list_items`, `products`, `aliases`)
  - Realtime подписки по таблицам для мгновенных обновлений
  - RLS-политики для изоляции данных пользователей и ролей в шаренных списках
- **Инвайты/шеринг**: через запись в `list_members` и ссылку-приглашение.

### Короткое мемо по ведению дневника прогресса
- Обновляйте прогресс по задачам в чеклисте ниже регулярно (желательно ежедневно/по завершении значимого шага).
- Не удаляйте выполненные задачи: меняйте только их статус чекбоксом.
- Легенда статусов: `[ ]` — запланировано, `[.]` — в работе, `[x]` — готово.

### Пошаговый план (чеклист выполнения)
#### Этап 1 — Инфраструктура и настройки
- [ ] Создать проект в Supabase, включить Realtime
  - [x] Создать проект и получить `SUPABASE_URL` и `ANON_KEY`
  - [ ] Включить Realtime для нужных таблиц (после их создания)
- [ ] Настроить аутентификацию провайдеров
  - [ ] Включить Google и/или GitHub OAuth
  - [ ] Настроить redirect URL для Vercel превью и продакшена
- [ ] Подготовить проект на Vercel
  - [x] Импорт репозитория, включить Preview Deployments
  - [x] Добавить переменные окружения: `VITE_SUPABASE_URL`, `VITE_SUPABASE_ANON_KEY`
  - [ ] Добавить `VITE_GEMINI_API_KEY` или спланировать прокси (Edge Function)
- [ ] Добавить зависимости и базовую инициализацию
  - [x] Установить `@supabase/supabase-js`
  - [x] Создать `services/supabaseClient.ts`
  - [x] Проверить доступность переменных окружения в dev/preview/prod

#### Этап 2 — Аутентификация и профиль
- [x] Ввести контекст/провайдер сессии Supabase
  - [x] Обернуть приложение провайдером auth-состояния
  - [x] Кнопки Sign In/Sign Out в `Header`
- [ ] Экран входа/редирект
  - [ ] Простая форма/кнопки OAuth
  - [x] Форма входа по email (magic link)
  - [x] Обработка redirect back от провайдера
- [ ] Синхронизация профиля пользователя
  - [x] Создание/обновление записи в `profiles` при первом логине
  - [ ] Заменить `CURRENT_USER` на данные из сессии

#### Этап 3 — Схема БД и RLS
- [x] Создать таблицы
  - [x] `profiles`, `lists`, `list_members`, `list_items`, `products`, `aliases`
- [x] Связи, индексы, ограничения
  - [x] FK на владельца списка и принадлежность элементов списку
  - [x] Индексы: `list_items.list_id`, `list_members(list_id,user_id)`
- [x] Включить RLS и политики
  - [x] Политики чтения для участников
  - [x] Политики записи для ролей `owner`/`editor`
- [ ] Базовый сидинговый набор (опционально для dev)

#### Этап 4 — CRUD списков и элементов
- [ ] Экран/меню выбора активного списка
  - [x] Создание дефолтного «My list» при первом входе
  - [ ] Переключение между списками
- [ ] Интеграция `useShoppingList` с Supabase
  - [.] Загрузка `list_items` по активному `list_id`
  - [.] Добавление/обновление/удаление через Supabase
  - [ ] Оптимистичные апдейты и откат при ошибке
- [ ] Перенос `products`/`aliases` в БД (минимально для текущего UX)

#### Этап 5 — Realtime
- [x] Подписки на `list_items`
  - [x] Обработка insert/update/delete для активного списка
  - [x] Дедупликация/идемпотентность апдейтов в клиенте
- [ ] Presence (опционально)
  - [ ] Канал присутствия участников
  - [ ] Индикаторы «кто онлайн/кто редактирует»
- [ ] Регрессионные тесты в двух браузерах (разные пользователи)

#### Этап 6 — Шеринг и роли
- [ ] Генерация ссылки-приглашения
  - [ ] Создание токена/ссылки для `list_id`
  - [ ] Срок жизни и безопасность инвайта
- [ ] Присоединение по ссылке
  - [ ] Экран подтверждения входа в список
  - [ ] Создание записи в `list_members` (роль по умолчанию `editor`)
- [ ] Управление ролями и участниками
  - [ ] Просмотр участников списка
  - [ ] Смена роли (`viewer`/`editor`), передача прав `owner`
  - [ ] Выход из списка

#### Этап 7 — Gemini и безопасность ключа
- [x] Перенос ключа на `import.meta.env.VITE_GEMINI_API_KEY` или прокси
  - [ ] Вариант A: безопасная работа на клиенте с ограничениями ключа
  - [ ] Вариант B: Vercel/Supabase Edge Function-прокси для вызовов
- [ ] Устойчивость парсинга и локализация (ru/en)
  - [ ] Тест кейсов для `ADD/REMOVE/UPDATE`
  - [ ] Ошибки сети/квоты — пользовательские сообщения

#### Этап 8 — Полировка и UX
- [ ] Улучшить потоки Add/Update/Remove
  - [ ] Подтверждения опасных действий
  - [ ] Undo/redo (минимум — отмена последнего удаления)
- [ ] Права доступа в UI
  - [ ] Скрывать недоступные действия для `viewer`
- [ ] Операции со списками
  - [ ] Переименование, удаление списка (с подтверждением)

#### Этап 9 — Тестирование, наблюдаемость, деплой
- [ ] E2E-сценарии
  - [ ] Совместное редактирование (2 пользователя)
  - [ ] Инвайт по ссылке и выход из списка
  - [ ] RLS негативные кейсы (нет доступа к чужим данным)
- [ ] Наблюдаемость (опционально)
  - [ ] Логи/метрики/алерты (Sentry/Logtail)
- [ ] Деплой и выпуск
  - [ ] Preview-проверка в Vercel
  - [ ] Продакшен-релиз и пост-релизная проверка

### Модель данных (черновик)
- `profiles`: id (uuid, = auth.uid), name, avatar_url, created_at
- `lists`: id (uuid), name, owner_id (uuid -> profiles.id), created_at
- `list_members`: list_id (uuid), user_id (uuid), role ('owner'|'editor'|'viewer'), created_at
- `list_items`: id (uuid), list_id (uuid), name, quantity numeric, unit text, priority int, status text, assignee_user_id uuid, created_at, updated_at
- `products`: id (uuid), name text, alias_id uuid, category text
- `aliases`: id (uuid), name text

Ключевые индексы: по `list_items.list_id`, `list_members(list_id,user_id)`, `lists.owner_id`.

RLS (в общих чертах):
```sql
-- Только участники списка видят его элементы
create policy "list_items: select for members" on list_items
  for select using (
    exists(
      select 1 from list_members m
      where m.list_id = list_items.list_id and m.user_id = auth.uid()
    )
  );

-- Редактирование только для owner/editor
create policy "list_items: modify for editors" on list_items
  for all using (
    exists(
      select 1 from list_members m
      where m.list_id = list_items.list_id
        and m.user_id = auth.uid()
        and m.role in ('owner','editor')
    )
  ) with check (
    exists(
      select 1 from list_members m
      where m.list_id = list_items.list_id
        and m.user_id = auth.uid()
        and m.role in ('owner','editor')
    )
  );
```

### Реализация — этапы
1) Инфраструктура и настройки
   - Создать проект в Supabase, включить Realtime.
   - Настроить OAuth провайдеры (Google/GitHub) и email magic links (по необходимости).
   - На Vercel создать проект, подключить репозиторий, прописать переменные окружения:
     - `VITE_SUPABASE_URL`, `VITE_SUPABASE_ANON_KEY`
     - `VITE_GEMINI_API_KEY` (или прокси/edge-функция, чтобы не светить ключ в браузере)
   - Добавить `@supabase/supabase-js` в зависимости.

2) Аутентификация и профиль
   - Подключить Supabase Auth UI/логин (email+OAuth) и обернуть приложение в провайдер сессии.
   - При первом логине — синхронизировать запись в `profiles` (trigger/edge function или клиентом).
   - Заменить `CURRENT_USER` на реальные данные из сессии.

3) Схема БД и RLS
   - Создать таблицы (`profiles`, `lists`, `list_members`, `list_items`, `products`, `aliases`).
   - Включить RLS на таблицах и прописать политики чтения/записи для участников.
   - Создать индексы и минимальные ограничения (FK, уникальности).

4) CRUD списков и элементов
   - Экран/меню выбора активного списка (минимум: один дефолтный «My list» при первом входе).
   - Переписать `useShoppingList` на загрузку/запись в Supabase:
     - чтение `list_items` по `list_id`
     - добавление/обновление/удаление элементов
     - оптимистичные апдейты + откат при ошибке
   - Синхронизация `products`/`aliases` с БД (минимально — в границах текущего пользователя/списка).

5) Realtime
   - Подписки на изменения `list_items` выбранного списка (insert/update/delete) -> обновлять локальный стейт.
   - Канал presence (необязательно на первом проходе): показывать онлайн-участников и «кто редактирует».

6) Шеринг и роли
   - UI для «поделиться»: генерация ссылки приглашения, обработка перехода по ссылке.
   - Добавление участника в `list_members` с ролью `editor` по умолчанию; возможность понизить до `viewer`.
   - Отображение участников, выход из списка, передача прав owner.

7) Интеграция Gemini и безопасность ключа
   - Перевести доступ к ключу на `import.meta.env.VITE_GEMINI_API_KEY` или вынести запросы в прокси (Vercel Function / Supabase Edge Function).
   - Учитывать локализацию команд (русский/английский) и устойчивость парсинга.

8) Полировка и UX
   - Списки: выбор активного, переименование, удаление (с подтверждением).
   - Улучшить Add/Update/Remove поток с подтверждениями и откатами.
   - Права доступа в UI (скрывать недоступные действия для `viewer`).

9) Тестирование, наблюдаемость, деплой
   - Smoke/E2E сценарии: совместное редактирование из двух браузеров, инвайт по ссылке, RLS негативные кейсы.
   - Логи и алерты: подключить Sentry/Logtail (опционально).
   - Авто-превью в Vercel для PR.

### План изменений в коде (минимально инвазивный)
- Добавить `services/supabaseClient.ts` и провайдер аутентификации в корне (обертка над `App`).
- Расширить `useShoppingList`:
  - Инициализация: загрузить `list_items` для активного `list_id` из Supabase.
  - Операции редактирования — заменить `dispatch`-только подход на вызовы Supabase + локальный `dispatch`.
  - Включить подписку Realtime на `list_items` выбранного списка.
- Компоненты UI:
  - `ShareModal`: выдавать реальную ссылку приглашения (deeplink), по клику — добавлять пользователя в `list_members`.
  - `Header`: отрисовывать данные текущего пользователя из профиля (аватар/имя), кнопка Sign In/Sign Out.
  - `ProductDatabaseView` и связанные действия — работать с таблицами `products`/`aliases`.

### Переменные окружения
- `VITE_SUPABASE_URL`
- `VITE_SUPABASE_ANON_KEY`
- `VITE_GEMINI_API_KEY` (или убрать с фронта и использовать прокси)

### Критерии готовности (MVP)
- Пользователь может войти, создать (или получить дефолтный) список, добавлять/удалять/редактировать элементы, изменения сохраняются в БД.
- Шеринг по ссылке: приглашенный видит список, может редактировать (роль editor), изменения видны обоим в реальном времени.
- RLS гарантирует, что посторонние пользователи не имеют доступа к чужим данным.

### Риски и меры
- Утечка ключа Gemini: вынести в серверную среду (edge function) или ограничить ключ и домены.
- Конфликты прав доступа: строго тестировать RLS, покрыть негативные сценарии.
- Реальное время и дубли апдейтов: аккуратная дедупликация событий и idempotency на клиенте.

### Этапность и сроки (оценка)
- Неделя 1: Инфра, Auth, схема БД, RLS, базовый CRUD списков/элементов.
- Неделя 2: Realtime, шаринг/роли, интеграция продуктового каталога и алиасов.
- Неделя 3: Полировка UX, безопасность Gemini, тесты, стабилизация, деплой.


